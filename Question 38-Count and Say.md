[toc]
# 38.报数

### 题目

    报数序列是一个整数序列，按照其中的整数的顺序进行报数，得到下一个数。其前五项如下：
        1.     1
        2.     11
        3.     21
        4.     1211
        5.     111221
        
    1 被读作  "one 1"  ("一个一") , 即 11。
    11 被读作 "two 1s" ("两个一"）, 即 21。
    21 被读作 "one 2",  "one 1" （"一个二" ,  "一个一") , 即 1211。
        
    给定一个正整数 n（1 ≤ n ≤ 30），输出报数序列的第 n 项。
    注意：整数顺序将表示为一个字符串。
        示例 1:
            输入: 1
            输出: "1"
            
        示例 2:
            输入: 4
            输出: "1211"

---

### 解题笔记

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用时3小时，耗时不在思路上，主要在写法与自我怀疑上。总觉得应该会有规律，但是看到最后各种答案的时候，心里还是万草泥马奔腾的。整体看，这道题思路比较单一，而且写法暴力，写完不是很过瘾。

##### 1）双循环

```
var countAndSay = function(n) {
    let arr = ["1"];

    let str = "1";
    let count = 1;

    for (let i = 0;i < n - 1;i++) {
      let copy = "";

      for (let j = 0; j < str.length; j++) {

        if (arr[0] === str[j + 1]) {
            count++;
            continue;
          }

          copy += count + arr[0];
          arr = [str[j + 1]];
          count = 1;
        }

        str = copy;
        arr = [str[0]];
      }

      return str;
}

```

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我在写的时候，主要的卡点就在第一个字符和最后一个字符的判断上。主要思考点在——1）如果第一个字符就是个单独的字符，那么该怎么才能返回第一个字符的报数情况，然后继续判断第二个；2）最后一个循环时，如何把最后的报数添加到字符串中；<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;比较绕的地方就是**n - 1、数据的比较、count的初始化及计数、以及arr的赋值**：<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**首先n - 1，循环少一次的逻辑。** 因为初始化，给str赋值了1，所以**n = 1的情况是跳过的，** 通过初始化已经实现。**那么整体的循环就随之少了1次**；<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**然后是数据的比较。** 如果跟字符串**当前值进行比较**的话，那么count的初始化不好操作。因为count的初始化会出现在**两个位置**，一个是**字符串的首位**（即首位与第二位不相等的情况）、另一个**出现不相等值，需要停止计数时。** 这两种情况的本质区别是**第一种是相等判断，第二种是不等判断。** <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一种情况因为出现在字符串的首位，如果跟当前索引值比较，那么肯定是要**判断相等**的，这样如果初始化count值是0的话，才能通过+1来计数。那么**为什么count不直接初始化为1呢？** 因为从写法逻辑上来看，**每判断一次相等，count应该+1，** 所以从首位的情况看，count的初始化值，应该为0，那么这就**与第二种情况矛盾了**；<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二种情况的出现，要执行**两步操作**，**首先**将之前的计数情况插入到字符串中，给arr重新赋值，**然后**初始化count。这里就需要注意了，因为比较的是当前的索引值，所以必须将count初始化为1，因为本次已经是下一循环的第一次了。
而如果count初始化仍为0的话，通过 **--操作**，再执行一次当前循环，又耗费了性能。不难看出，**跟当前索引值进行比较，实现起来过于复杂。** 所以，通过**跟当前索引的下一值进行比较，达到统一的效果。并且最后一次的判断必定为false，可以执行添加的操作**；<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**再然后是count的初始化及计数。** 因为是与当前索引值的下一个值进行比较，所以实际上每次的查找都是少了一次的。而且如果出现当前值仅有一个的情况下，相等判断必为flase，而对当前值的报数又为1。所以在这种逻辑下，**count的初始化值必须为1，每次判断相等时，count就+1**；<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**最后是arr的赋值。** 分两种情况——**1）** 是字符串循环内的赋值；**2）** 是对于报数次数循环内的赋值。**首先是第一种，** 对于字符串循环内的赋值，因为比较的是当前索引值的下一项，而且count计数为1。所以每次一个count的判断周期结束，都将arr的赋值为下一个要计数的字符值；**第二种是报数次数循环内的赋值。** 因为报数循环每循环一次，意味着str更新了一次，那么将从首位开始循环。那么根据逻辑，**每个count计数开始时，当前索引值都是跟数组值相等的，** 所以每次报数循环结束，都将arr赋值为新str的首位（即str[0]）;
对于字符串的初始化与赋值，逻辑简单，不再过多赘述；

##### 2）双函数

```
var countAndSay = function(n) {
    let str = "1";
    for (let i = 2; i <= n; i++) {
        str = saySomething(str);
    }
    return str;
};

var saySomething = function (s) {
    s += '';
    let str = "";
    let j;
    for (let i = 0; i < s.length;) {
        j = i + 1;
        while (s[i] == s[j]) {
            j++;
        }
        str += ((j - i) + s[i]);
        i = j;
    }
    return str;
}

```

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;双函数与双循环，思路都是一样的，只是拆分成2个函数

##### 3）暴力法


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;暴力法就不上代码了，太长了。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为限定了输入范围，所以最快的写法就是把所有的结果都写在了一个数组里，数组第一项为空，然后直接返回以传入参数为索引的对应值。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以说是相当暴力了……哈哈哈


